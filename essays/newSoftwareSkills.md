---
layout: essay
type: essay
title: "What If Tim Duncan Taught Me How To Code?"
# All dates must be YYYY-MM-DD format!
date: 2024-05-10
published: true
labels:
  - Software Engineering
  - Learning
  - Web Dev
  - UI
  - Open Source Software Development
  - Development Environments
  - Configuration Management
---
<img width="303px" class="rounded float-start pe-4" src="../img/duncan.jpg">
<h1>Why These Software Engineering Concepts are Fundamental</h1>
&ensp;Personally I am a big fan of basketball and the NBA. I also am a die-hard San Antonio Spurs fan. Many of you may see where I am going with this but for those of you who are unfamiliar with the NBA, I will explain. Tim Duncan, arguably the greatest power forward of all time, lead a dynasty with the San Antonio Spurs and his nickname was, 'The Big Fundamental'. I grew up watching him and his teammates, Tony Parker and Manu Ginobili, win multiple championships and defeat all-time greats like Shaq and Kobe. A big reason that Tim Duncan is called 'The Big Fundamental' is his slow and methodical style of play. His signature move, the bank shot, was not flashy and seen as a move of the past. But it was his signature move because it gave him room to operate.

&ensp;To understand why Tim Duncan loved the bank shot so much we need to dive into the past. The NBA was not always a league centered around the 3-point shot and fast placed plays. In the past the NBA played a much slower game that allowed tighter defense and facilitated players that scored in the painted area. Centers and Forwards would often battle against one another and seeing a player dribble the ball up the court and immediately shoot a 3-point shot was a much rarer occurrence. The court was more crowded and the 3-point line had just been moved a few years prior to TIm Duncan's NBA debut. This means the players of that era did not grow up playing with the 3-point line and many were not accustomed to shooting the longer range shots. All of this culminates to a more crowded painted area and players shooting more mid-range 2-pointers as many of them only practiced shooting from 22-23 feet out.

&ensp;Basketball players are always looking for space, they can't live without it. But in the past it was even harder to make your own space since the floor was more crowded. This is where the bank shot comes in. With less wiggle room, the bank shot facilitates a higher point of release. It also gives you more room for error in your shot so you can be more consistent. Now let us look at what it did specifically for Duncan. As a Power Forward and Center, he often operated in the 'post' which means the area under the basket or close to the basket. Down in the post defenders often are making much more physical contact to deny the ball from being passed into the painted area. This is because shots in the painted area are typically much more efficient than those outside of it. This often required players in the post to be tall and catch the ball high up where most other players could not reach. This combined with Duncan's passing ability combined to be a deadly weapon. Once Duncan caught the ball up high he was in a position to pass it, shoot it, or bully his way to the basket. Most importantly, the bank shot gave him options and defenders had to respect all of the options or they would be taken advantage of. Duncan did not need to be the fastest player on the court or the strongest. What he did was equip himself with all of the tools available to him and he lived through his fundamentals.

&ensp;Much like Tim Duncan's bank shot, software engineers must continue to add tools that enable them to do operate more freely. In my experiences learning the software engineering concepts I use today, I have learned how important these tools can be. I have been saved a multitude of times this semester by utilizing these software engineering concepts and they allow me to make mistakes. All software engineers can at least somewhat agree that mistakes are sometimes the only way we can find the solution. Through mistakes we can learn what works and what doesn't work. If we are limited in the range of how we can operate as software engineers, we will not be able to perform to our potential. Tools such as Configuration Management, Development Environments, and Open Source Software Development can be seen as the 'triple-threat' of software engineering.

<img width="303px" class="rounded float-start pe-4" src="../img/github-logo.png">
<h3>Configuration Management</h3>
&ensp;Configuration management and version control are concepts that are possibly the most fundamental concept of software engineering. These concepts facilitate software engineers and allow them to work concurrently as a team. It allows the team members to work together in an organized fashion to develop a project and ensure issues are resolved quickly and efficiently. These concepts can even help software engineers when working by themselves as it helps them stay organized and maintains various versions of the implementations of a project. During my time as a computer engineering student, I was able to utilize these concepts through [git](https://git-scm.com/doc)  and [github](https://github.com/).

&ensp;When I think about instances I have worked on code projects before I had learned how to fully utilize git and github, I often feel regret. I regret I had not learned about these tools sooner and I regret wasting so much time on issues that could have been easily solved by properly utilizing configuration management and version control. I am sure almost every single college student or graduate can relate to a moment when disaster struck. I am talking about a moment when technology fails us. Often these moments are built upon long standing relationships of trust between man and machine. But that trust is always toppled when the inevitable failure occurs. I have in the past lost large portions of my work due to carelessness and a lack of configuration management and version control. Had I simply utilized the tools I had available to me I could have saved so much of my time and effort.

&ensp;This semester I have applied these concepts to the group project I have been working on for my Software Engineering I course. This project can be viewed in the 'FlavorForge' Project on my professional portfolio. Github made working together quite simple and easy. We were able to discuss our goals and ideas for the project during our meetings with one another face to face and were able to assist each other with any issues remotely. Version control also saved us multiple headaches since we were able to reference older commits and reference any old code if changes needed to be reverted. Many of our team members were not fluent in git and using github so we ran into problems quite often. Even while running into issues using git and github, the version control saved us time and time again. Not all problems can be solved with the use of configuration management and version control, but I feel more confident and willing to take risks when I know that I can always reference back to an older version of my project.

<img width="303px" class="rounded float-start pe-4" src="../img/intellij.png">
<h3>Development Environments</h3>
&ensp;Properly setting up and understanding my development environment is a crucial step to any successful project. Working on coding projects without a development environment or one that is set up properly is like trying to read without glasses or writing with a stick. Development environments are designed to help software engineers be more efficient and observant.

&ensp;The development environment I utilized for my Software Engineering I course was IntelliJ IDEA. At first it took some time to become accustomed to the multitude of keyboard shortcuts available but once I found a few favorites it felt like second nature. Sometimes I am forced to program on a linux system for my other courses. It would be a major understatement to say that I desperately missed my IntelliJ keyboard shortcuts. Simply saving a document on VIM is much more of a headache than pressing ctrl-s in IntelliJ. Being able to commit and push using IntelliJ is nice as well. On a linux system it is not nearly as easy as it is on IntelliJ. Sometimes I feel as though I run into many more issues when committing and pushing through IntelliJ so I think I will continue to use git commands or other methods.

<img width="500px" class="rounded float-start pe-4" src="../img/meteor.png">
<h3>Open Source Software Development</h3>
&ensp;Open source software development is a concept that has proven to be an important part of the software engineering world. With certain intellectual property(IP) there exists copyright laws that protect the owner of the IP from others redistributing it or a derivative of it. In software engineering there exists licenses that allow other developers to redistribute derivatives of a project. When we talk about Open source software development we are discussing the projects with these types of licenses available. There are different types of licenses available that vary in their limitations. The main points are that it allows free redistribution, provides the source code, and allows modification and derived works.

&ensp;These open source projects have assisted me in developing multiple projects. Meteor is an open source project that allows access to thousands of libraries that help with web development. Utilizing Meteor has facilitated my journey in learning web development and deploying a functional website. I saw myself become more comfortable with Javascript and quickly expand my capabilities. I can focus on the overall structure of the project and worry about important details instead of developing my own functions for basic UI components. I instead could focus my efforts on implementing various features and the back-end of my project. I have also worked with Android's open source project Kotlin. Their tutorials also not only help you understand how to use their framework, but teach users various software engineering concepts such as Object-Oriented design and database management using SQLite. This is an overlooked part of open source projects as they often exist to enable a wide variety of experience levels to work with them.

<h3>Conclusion</h3>
&ensp;As you can see the software engineering fundamentals have opened the paint up for me. Now when I am met face to face with an obstacle I have multiple ways to tackle it. If there is an issue with my machine or a loss of progress I will have my version control implemented. If I am spending too much time typing and debugging I can become more efficient by learning more shortcuts in my development environment. If I am working on a large project that will require me to create a lot of different working parts and I do not think I can finish all of that work in time I can look to an open source project. I can try to find a project or multiple projects that include libraries with functions I can use instead of writing my own. These concepts expand your ability to work and develop as a software engineer. In every competitive sphere I have heard people preach the importance of having strong fundamentals. In physics my professors told me I need strong calculus fundamentals in order to expand on my understanding. In basketball Tim Duncan showed that good fundamentals do translate to greatness. Now in software engineering it is my turn to show the importance of these fundamentals.